---
title: 'Are elevated lactate levels associated with ICU mortality?'
author: "..."
date: "January, 2025"
output:
  pdf_document: 
    toc: true
    toc_depth: 4
    number_sections: true
    fig_width: 7
    fig_height: 5
    fig_caption: true
    keep_tex: false
    latex_engine: xelatex
    highlight: tango
    citation_package: natbib
header-includes:
- \usepackage{xcolor}
- \usepackage{framed}
- \usepackage{listings}
- \usepackage{fancyhdr}
- \usepackage{geometry}
- \usepackage{caption}
- \usepackage{booktabs}
- \usepackage{longtable}
- \usepackage{array}
- \usepackage{multirow}
- \usepackage{wrapfig}
- \usepackage{float}
- \usepackage{colortbl}
- \usepackage{pdflscape}
- \usepackage{tabu}
- \usepackage{threeparttable}
- \usepackage{graphicx}
- \geometry{top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm}
- \pagestyle{fancy}
- \fancyfoot[C]{\thepage}
- \renewcommand{\headrulewidth}{0.4pt}
- \renewcommand{\footrulewidth}{0.4pt}
editor_options: 
  markdown: 
    wrap: 72
---

\newpage

Authors' information

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Nombre} & Johanna Ursula Albers \\
\hline
\textbf{Email} & johanna.albers@estudiants.urv.cat\\
\hline
\textbf{GitHub} & https://github.com/ \\
\hline
\textbf{LinkedIn} & https://www.linkedin.com/in/ \\
\hline
\textbf{Fecha} & \today \\
\hline
\end{tabular}
\end{center}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Nombre} & Marco Russo \\
\hline
\textbf{Email} & mrussorb@uoc.edu \\
\hline
\textbf{GitHub} & https://github.com/marcusRB/ \\
\hline
\textbf{LinkedIn} & https://www.linkedin.com/in/marcusrb/ \\
\hline
\textbf{Fecha} & \today \\
\hline
\end{tabular}
\end{center}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{Nombre} & Noa-Sibila Janer Oliver \\
\hline
\textbf{Email} & noa-sibila.janer@estudiants.urv.cat \\
\hline
\textbf{GitHub} & https://github.com/ \\
\hline
\textbf{LinkedIn} & https://www.linkedin.com/in/ \\
\hline
\textbf{Fecha} & \today \\
\hline
\end{tabular}
\end{center}
\newpage


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, 
                      fig.width = 10, fig.height = 6)
```

# Project overview

**Research Question**: Are elevated lactate levels associated with ICU
mortality? Study Design: Retrospective cohort study using MIMIC-III
database Primary Analysis: Association between first lactate measurement
post-ICU admission and in-hospital mortality

## Data Description

MIMIC-III is a relational database consisting of 26 tables. Tables are
linked by identifiers which usually have the suffix ‘ID’. For example,
SUBJECT_ID refers to a unique patient, HADM_ID refers to a unique
admission to the hospital, and ICUSTAY_ID refers to a unique admission
to an intensive care unit.

Charted events such as notes, laboratory tests, and fluid balance are
stored in a series of ‘events’ tables. For example the OUTPUTEVENTS
table contains all measurements related to output for a given patient,
while the LABEVENTS table contains laboratory test results for a
patient.

Tables prefixed with ‘D\_’ are dictionary tables and provide definitions
for identifiers. For example, every row of CHARTEVENTS is associated
with a single ITEMID which represents the concept measured, but it does
not contain the actual name of the measurement. By joining CHARTEVENTS
and D_ITEMS on ITEMID, it is possible to identify the concept
represented by a given ITEMID.

Developing the MIMIC data model involved balancing simplicity of
interpretation against closeness to ground truth. As such, the model is
a reflection of underlying data sources, modified over iterations of the
MIMIC database in response to user feedback. Care has been taken to
avoid making assumptions about the underlying data when carrying out
transformations, so MIMIC-III closely represents the raw hospital data.

Broadly speaking, five tables are used to define and track patient
stays: ADMISSIONS; PATIENTS; ICUSTAYS; SERVICES; and TRANSFERS. Another
five tables are dictionaries for cross-referencing codes against their
respective definitions: D_CPT; D_ICD_DIAGNOSES; D_ICD_PROCEDURES;
D_ITEMS; and D_LABITEMS. The remaining tables contain data associated
with patient care, such as physiological measurements, caregiver
observations, and billing information.

In some cases it would be possible to merge tables—for example, the
D_ICD_PROCEDURES and CPTEVENTS tables both contain detail relating to
procedures and could be combined—but our approach is to keep the tables
independent for clarity, since the data sources are significantly
different. Rather than combining the tables within MIMIC data model, we
suggest researchers develop database views and transforms as
appropriate.

## MIMIC-III v1.4

The current version of the database is v1.4. When referencing this
version, we recommend using the full title: MIMIC-III v1.4[^1].

[^1]: Johnson, A., Pollard, T., & Mark, R. (2016). MIMIC-III Clinical
    Database (version 1.4). PhysioNet. RRID:SCR_007345.
    <https://doi.org/10.13026/C2XW26>

MIMIC-III v1.4 was released on 2 September 2016. It was a major release
enhancing data quality and providing a large amount of additional data
for Metavision patients.

------------------------------------------------------------------------

# Data Extraction & Preparation

## Database setup, cohort extraction

```{r database setup}
library(dplyr)
library(tidyr)
library(tibble)
library(lubridate)
library(readr)
library(stringr)
library(ggplot2)
library(data.table)
library(odbc)
library(RMariaDB)
```

```{r}
# Get the credentials file
# It looks like:
################
#username=your.user.name
#password=your.password.assigned
################
creds_file = "creds.txt"
```

```{r}
# Set the username and password
creds <- readLines(creds_file)
cred_list <- setNames(
  sub(".*=", "", creds),
  sub("=.*", "", creds)
)
```

```{r}
con <- dbConnect(
  drv = RMariaDB::MariaDB(),
  username = cred_list[["username"]],
  password = cred_list[["password"]],
  host = "ehr3.deim.urv.cat",
  dbname = "mimiciiiv14",
  port = 3306
)
```

```{r, results='hide'}
#| echo: false
dbListTables(con)
```

We constructed a cohort at the level of individual lactate measurements
obtained during ICU stays. Each row in the dataset corresponds to a
single lactate measurement, and all lactate values recorded during any
ICU stay were included.

Lactate measurements were assigned to ICU stays based on their
timestamp: a measurement was linked to an ICU stay only if it occurred
between the ICU admission (intime) and discharge (outtime) times.

ICU mortality was derived from hospital admission outcomes. For patients
with multiple ICU stays within the same hospital admission, ICU
mortality was assigned exclusively to the final ICU stay if the patient
died during that admission; all preceding ICU stays were labeled as
non-fatal. This approach allows ICU-level mortality attribution in the
absence of a direct ICU death indicator. The final cohort comprised
129,966 lactate measurements, representing multiple ICU stays and
hospital admissions across patients.

```{r}
library(DBI)
dbExecute(con, "SET SQL_BIG_SELECTS=1;")
```

```{r}
cohort_query <- "
        WITH icu_ordered AS (
        SELECT
            i.subject_id,
            i.hadm_id,
            i.icustay_id,
            i.intime,
            i.outtime,
            a.hospital_expire_flag AS hospital_dead,
            ROW_NUMBER() OVER (
                PARTITION BY i.subject_id, i.hadm_id
                ORDER BY i.outtime DESC
            ) AS rn_icu
        FROM ICUSTAYS i
        JOIN ADMISSIONS a
            ON i.hadm_id = a.hadm_id
    ),
    lactate_first AS (
        SELECT
            io.subject_id,
            io.hadm_id,
            io.icustay_id,
            l.charttime as lactate_time,
            l.value as lactate_value,
            l.valuenum as lactate_value_num,
            l.valueuom as lactate_units,
            l.flag as lactate_flag,
            ROW_NUMBER() OVER (
                PARTITION BY io.icustay_id
                ORDER BY l.charttime ASC
            ) AS rn
        FROM LABEVENTS l
        INNER JOIN icu_ordered io USING(subject_id, hadm_id)
        WHERE l.itemid = 50813
          AND l.value IS NOT NULL
          AND l.charttime BETWEEN io.intime AND (io.intime + INTERVAL '24' HOUR)
    ),
    ck_first AS (
        SELECT
            io.subject_id,
            io.hadm_id,
            io.icustay_id,
            l.charttime as ck_time,
            l.value as ck_value,
            l.valuenum as ck_value_num,
            l.valueuom as ck_units,
            l.flag as ck_flag,
            ROW_NUMBER() OVER (
                PARTITION BY io.icustay_id
                ORDER BY l.charttime ASC
            ) AS rn
        FROM LABEVENTS l
        INNER JOIN icu_ordered io USING(subject_id, hadm_id)
        WHERE l.ITEMID = 50910
          AND l.charttime BETWEEN io.intime AND (io.intime + INTERVAL '24' HOUR)
    ),
    bilirubin_first AS (
        SELECT
            io.subject_id,
            io.hadm_id,
            io.icustay_id,
            l.charttime as bilirubin_time,
            l.value as bilirubin_value,
            l.valuenum as bilirubin_value_num,
            l.valueuom as bilirubin_units,
            l.flag as bilirubin_flag,
            ROW_NUMBER() OVER (
                PARTITION BY io.icustay_id
                ORDER BY l.charttime ASC
            ) AS rn
        FROM LABEVENTS l
        INNER JOIN icu_ordered io USING(subject_id, hadm_id)
        WHERE l.ITEMID = 50885
          AND l.charttime BETWEEN io.intime AND (io.intime + INTERVAL '24' HOUR)
    ),
    mabp_first AS (
        SELECT
            io.subject_id,
            io.hadm_id,
            io.icustay_id,
            c.CHARTTIME as mabp_time,
            c.value as mabp_value,
            c.valuenum as mabp_value_num,
            c.valueuom as mabp_units,
            ROW_NUMBER() OVER (
                PARTITION BY io.icustay_id
                ORDER BY c.charttime ASC
            ) AS rn
        FROM CHARTEVENTS c
        INNER JOIN icu_ordered io USING(subject_id, hadm_id, icustay_id)
        WHERE c.itemid = 220052
          AND c.valuenum IS NOT NULL
          AND c.charttime BETWEEN io.intime AND (io.intime + INTERVAL '24' HOUR)
    ),
    icu_with_lactate AS (
        SELECT DISTINCT subject_id, hadm_id, icustay_id
        FROM lactate_first
        WHERE rn = 1
    )
    SELECT
        ROW_NUMBER() OVER (ORDER BY iu.subject_id, iu.hadm_id, iu.icustay_id) AS row_id,
        iu.subject_id,
        p.dob,
        YEAR(iu.intime) - YEAR(p.DOB) AS age_icu_entry,
        YEAR(iu.outtime) - YEAR(p.DOB) AS age_icu_exit,
        p.gender,
        iu.hadm_id,
        iu.icustay_id,
        iu.intime,
        iu.outtime,
        iu.hospital_dead,
        CASE
            WHEN iu.hospital_dead = 1 AND iu.rn_icu = 1 THEN 1
            ELSE 0
        END AS icu_dead,
        lf.lactate_time,
        lf.lactate_value,
        lf.lactate_value_num,
        lf.lactate_units,
        lf.lactate_flag,
        ck.ck_time,
        ck.ck_value,
        ck.ck_value_num,
        ck.ck_units,
        ck.ck_flag,
        bil.bilirubin_time,
        bil.bilirubin_value,
        bil.bilirubin_value_num,
        bil.bilirubin_units,
        bil.bilirubin_flag,
        mb.mabp_time,
        mb.mabp_value,
        mb.mabp_value_num,
        mb.mabp_units
    FROM icu_ordered iu
    INNER JOIN icu_with_lactate iwl ON iwl.subject_id = iu.subject_id 
        AND iwl.hadm_id = iu.hadm_id 
        AND iwl.icustay_id = iu.icustay_id
    LEFT JOIN lactate_first lf ON lf.subject_id = iu.subject_id 
        AND lf.hadm_id = iu.hadm_id 
        AND lf.icustay_id = iu.icustay_id
        AND lf.rn = 1
    LEFT JOIN ck_first ck ON ck.subject_id = iu.subject_id 
        AND ck.hadm_id = iu.hadm_id 
        AND ck.icustay_id = iu.icustay_id
        AND ck.rn = 1
    LEFT JOIN bilirubin_first bil ON bil.subject_id = iu.subject_id 
        AND bil.hadm_id = iu.hadm_id 
        AND bil.icustay_id = iu.icustay_id
        AND bil.rn = 1
    LEFT JOIN mabp_first mb ON mb.subject_id = iu.subject_id 
        AND mb.hadm_id = iu.hadm_id 
        AND mb.icustay_id = iu.icustay_id
        AND mb.rn = 1
    LEFT JOIN PATIENTS p ON p.subject_id = iu.subject_id
    ORDER BY iu.subject_id, iu.hadm_id, iu.icustay_id;
"

initial_df <- dbGetQuery(con, cohort_query) 
initial_df %>% glimpse()
```

------------------------------------------------------------------------

## Data cleaning, variable creation

```{r}
# Are there duplicates?
sum(duplicated(initial_df))
```

```{r}

clean_values_df <- initial_df %>%
  mutate(
    lactate_value_num = case_when(
      # For samples containing ">" or "GREATER THAN 30" assign value 31
      
      str_detect(lactate_value, fixed(">")) | 
      str_detect(toupper(lactate_value), "GREATER THAN") ~ 31,
      
      TRUE ~ as.numeric(lactate_value) # Convert to numeric value, 
      # samples with numbers and letters will be converted to NA
    )
  ) %>%
  filter(!is.na(lactate_value_num)) # Delete whole row if lactate value is null


# Check for suspicious values
clean_values_df %>%
  filter(lactate_value_num <= 0 | lactate_value_num > 31)

```

Imputed 'normal' for all missing records in the lactate_flag variable.

```{r}
clean_values_df <- clean_values_df %>%
  mutate(
    lactate_flag = if_else(is.na(lactate_flag), "normal", lactate_flag)
  )


ggplot(clean_values_df, aes(x = lactate_value_num, fill = lactate_flag)) +
  geom_histogram(bins = 60, alpha = 0.6, position = "identity", color = "white") +
  
  scale_x_log10() +
  
  scale_fill_manual(values = c("normal" = "#2ecc71", "abnormal" = "#e74c3c")) +
  
  labs(
    title = "Distribution of Lactate Values by Flag",
    x = "Lactate Value (mmol/L) - Log Scale",
    y = "Frequency",
    fill = "Lactate Flag"
  ) +
  
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "bottom"
  )
```


Validate mortality coherence 1: icu_dead cannot be true if hospital_dead is false.

```{r}
clean_values_df %>%
  filter(icu_dead == 1 & hospital_dead == 0) %>%
  nrow()
```

Validate mortality coherence 2: each subject should have at most one recorded death across ICU and hospital stays.

```{r}
death_counts <- clean_values_df %>%
  group_by(subject_id) %>%
  summarise(
    hosp_dead = n_distinct(hadm_id[hospital_dead == 1], na.rm = TRUE),
    icu_dead  = n_distinct(icustay_id[icu_dead == 1], na.rm = TRUE)
  ) %>%
  filter(icu_dead > 1)
death_counts
```
A data inconsistency was identified involving a single subject with two incorrectly assigned mortality flags; these records were manually rectified to ensure data integrity.

```{r}
clean_values_df <- clean_values_df %>%
  mutate(
    # Reassign hospital_dead from first admission
    hospital_dead = if_else(subject_id == 17796 & hadm_id == 119823, 0, hospital_dead),
    
    # Reassign icu_dead from first ICU stay
    icu_dead = if_else(subject_id == 17796 & hadm_id == 119823, 0, icu_dead)
  )
```


```{r}
# Show the distribution of lactate values (log scale)
ggplot(clean_values_df, aes(lactate_value_num)) +
  geom_histogram(bins = 50, fill = "steelblue", color = "white") +
  scale_x_log10() + 
  labs(title = "Distribution of lactate values (log scale)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

```
The final cohort for exploratory analysis comprises 21,016 unique subjects, accounting for 24,622 hospital admissions and 25,743 ICU stays. The dataset includes a total of 128,715 lactate observations, with an average of 5 measurements per ICU stay, providing a robust longitudinal perspective on patient biomarkers.

```{r}
summary(clean_values_df)
```
------------------------------------------------------------------------

## Exploratory analysis

### Missing values and imputations

After the imputation task the first step is select only the important features to doing the exploratory analysis

```{r}
names(clean_values_df)
```


```{r}
eda_columns <- c("subject_id", "dob", "age_icu_entry", "age_icu_exit",
                 "gender", "hadm_id", "icustay_id", "intime", "outtime",
                 "hospital_dead", "icu_dead", "lactate_time", "lactate_value_num",
                 "lactate_units", "lactate_flag", "ck_time", "ck_value_num", "ck_units",
                 "ck_flag", "bilirubin_time", "bilirubin_value_num", "bilirubin_units",
                 "bilirubin_flag", "mabp_time", "mabp_value_num", "mabp_units")

eda_df <- clean_values_df %>%
  select(eda_columns)
head(eda_df)
```

Checking the missing values

```{r}
as.data.frame(eda_df) %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  select(where(~ . > 0))
```

```{r}
library(naniar)
library(ggplot2)
# Visualize missing values by variable

missing_df <- clean_values_df %>%
  select(-row_id)

gg_miss_var(missing_df, show_pct = TRUE) +
labs(title = "Missing Values by Variable in Dataset Subset",
x = "Variables",
y = "Proportion of Missing Values")
```
```{r}
library(VIM)
aggr(missing_df, numbers = FALSE, prop = FALSE, sortVar = TRUE)
```

```{r}
# Check missing values
missing_summary <- sapply(eda_df, function(x) sum(is.na(x)))
missing_df <- data.frame(
    Column = names(missing_summary),
    Missing_Count = missing_summary,
    Missing_Percent = round(missing_summary/nrow(eda_df)*100, 2)
  ) %>%
  arrange(desc(Missing_Count))

print(missing_df)
```






------------------------------------------------------------------------

# Statistical Analysis

## Primary analysis (clustering, logistic regression, lineal model, etc., ROC curves)

------------------------------------------------------------------------

## Subgroup analyses, sensitivity analyses

## Create all figures and tables

------------------------------------------------------------------------

# Machine Learning modeling

------------------------------------------------------------------------

# Next steps

------------------------------------------------------------------------

# Conclusions

------------------------------------------------------------------------

# References

------------------------------------------------------------------------
